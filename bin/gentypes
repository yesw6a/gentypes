#! /usr/bin/env node

const fs = require('fs');
const figlet = require('figlet');
const Printer = require('@darkobits/lolcatjs');
const { program } = require('commander');
const inquirer = require('inquirer');
const process = require('child_process');
const appRoot = require('app-root-path');
console.log("ðŸš€ ~ file: gentypes ~ line 10 ~ appRoot", appRoot)

const quicktypeJSON = require('../lib/quicktypeJSON');
const fetch = require('../lib/fetch');
const { isJson, valueFindObject } = require('../utils');

const versionStr = figlet.textSync('GEN-TYPES');
const _version = require('../package.json').version;
const configPath = `${appRoot}/.gentypesrc`;

// åˆ›å»ºå£°æ˜Žæ–‡ä»¶
const genInterface = async (name, source) => {
  let s = source;
  try {
    s = JSON.parse(source);
  } catch (error) {}
  const { lines } = await quicktypeJSON('ts', name, JSON.stringify(s));
  const data = lines.join('\n');
  // è¯»å–é…ç½®æ–‡ä»¶å†…å®¹
  try {
    fs.statSync(configPath);
    const file = fs.readFileSync(configPath, 'utf8');
    let configJsonObj = {};
    try {
      configJsonObj = JSON.parse(file);
      if (!isJson(configJsonObj)) throw new Error();
      // è¾“å‡º interface
      const { outputPath } = configJsonObj;
      try {
        fs.statSync(outputPath);
      } catch (error) {
        fs.mkdirSync(outputPath);
      }
      const writerStream = fs.createWriteStream(`${outputPath}/${name}.ts`);
      writerStream.write(data);
      writerStream.end();
    } catch (error) {
      console.log('é…ç½®ä¸æ˜¯ä¸€ä¸ªjsonæ–‡ä»¶');
    }
  } catch (error) {}
};

// è¾“å‡ºç‰ˆæœ¬ä¿¡æ¯
program.version(
  Printer.default.fromString(
    `     \n               å¿«é€Ÿç”ŸæˆInterface v${_version}\n${versionStr}`
  )
);

// é€šè¿‡ fetch èŽ·å–æ•°æ®
const fetchData = async (url, options) => {
  let res = null;
  try {
    res = await fetch(url, options);
  } catch (error) {
    throw new Error(error);
  }
  if (!res) throw new Error('res is not valid.');
};

// æŒ‡ä»¤é›†
program
  .option('-n, --name <name>', 'æŒ‡å®šæŽ¥å£å')
  .option('-d, --data [data]', 'éœ€è¦ç”Ÿæˆå£°æ˜Žæ–‡ä»¶çš„æ•°æ®')
  .option('-url, --api_url [api_url]', 'æŒ‡å®šæŽ¥å£è¯·æ±‚åœ°å€')
  .option('-o, --api_options [api_options]', 'æŒ‡å®šæŽ¥å£é€‰é¡¹')
  .action(async (options) => {
    const { name, data, api_url, api_options } = options;
    if (Object.values(options).every((v) => !!v)) return;
    if (!name) throw new Error('æŽ¥å£åä¸èƒ½ä¸ºç©º');
    if (!api_url && !data) throw new Error('æŽ¥å£è¯·æ±‚åœ°å€æˆ–æ•°æ®ä¸èƒ½ä¸ºç©º');

    const d = data || (await fetchData(api_url, api_options));

    genInterface(name, d);
  });

// é…ç½®é…ç½®
const configPrompts = [
  {
    type: 'checkbox',
    name: 'options',
    message: 'è¯·é€‰æ‹©éœ€è¦é…ç½®çš„é€‰é¡¹: ',
    choices: ['outputPath', 'proxy'],
  },
];
const configPrompts2 = [
  {
    type: 'input',
    name: 'outputPath',
    message: 'è¯·è¾“å…¥å£°æ˜Žæ–‡ä»¶çš„è¾“å‡ºè·¯å¾„: ',
  },
  {
    type: 'editor',
    name: 'proxy',
    message: 'è¯·è¾“å…¥ä»£ç†åœ°å€ç›¸å…³å†…å®¹',
    default: `{
  "target": "",
  "reg": ""
}`,
  },
  // {
  //   type: 'input',
  //   name: 'proxyTarget',
  //   message: 'è¯·è¾“å…¥éœ€è¦ä»£ç†çš„ç›®æ ‡åœ°å€: ',
  // },
  // {
  //   type: 'input',
  //   name: 'proxyReg',
  //   message: 'è¯·è¾“å…¥ä»£ç†è§„åˆ™ï¼ˆæ­£åˆ™ï¼‰: ',
  // },
];
program.command('config').action(async () => {
  const { options } = await inquirer.prompt(configPrompts);
  if (!options.length) throw new Error('è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªé…ç½®é¡¹');
  const p2 = valueFindObject(configPrompts2, options, 'name');
  const configs = await inquirer.prompt(p2);
  let configJsonObj = {};

  const { proxy } = configs;
  if (proxy) {
    configs.proxy = JSON.parse(proxy);
  }

  try {
    fs.statSync(configPath);
    const file = fs.readFileSync(configPath, 'utf8');
    try {
      configJsonObj = JSON.parse(file);
      if (!isJson(configJsonObj)) throw new Error();
      Object.assign(configJsonObj, configs);
    } catch (error) {
      console.log('é…ç½®ä¸æ˜¯ä¸€ä¸ªjsonæ–‡ä»¶');
    }
  } catch (error) {}
  const configJsonStr = JSON.stringify(configJsonObj, null, '\t');
  const writerStream = fs.createWriteStream(configPath);
  writerStream.write(configJsonStr);
  writerStream.end();
});

const curlPrompts = [
  {
    type: 'input',
    name: 'name',
    message: 'è¯·è¾“å…¥å£°æ˜Žæ–‡ä»¶åç§°',
  },
  {
    type: 'editor',
    name: 'cURL',
    message: 'è¯·è¾“å…¥cURL',
  },
];
// é€šè¿‡cURLç”Ÿæˆå£°æ˜Žæ–‡ä»¶
program.command('curl').action(async () => {
  const { name, cURL } = await inquirer.prompt(curlPrompts);
  if (!name) throw new Error('æŽ¥å£åä¸èƒ½ä¸ºç©º');
  if (!cURL) throw new Error('cURLä¸èƒ½ä¸ºç©º');

  process.exec(`curl ${cURL}`, (error, stdout) => {
    if (error !== null) {
      throw new Error(error);
    }
    genInterface(name, stdout);
  });
});

program.parse(process.argv);
