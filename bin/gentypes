#! /usr/bin/env node

const fs = require('fs');
const figlet = require('figlet');
const Printer = require('@darkobits/lolcatjs');
const { program } = require('commander');
const inquirer = require('inquirer');
const cp = require('child_process');

const quicktypeJSON = require('../lib/quicktypeJSON');
const fetch = require('../lib/fetch');
const { isJson, valueFindObject } = require('../utils');
const {
  CONFIG_FILE_NAME,
  CONFIG_PATH,
  PROMPTS_CONFIG_OPTIONS,
  PROMPTS_CONFIG,
  PROMPTS_CURL,
  PROMPTS_DATA,
} = require('../utils/constants');

const versionStr = figlet.textSync('GEN-TYPES');
const _version = require('../package.json').version;

// è¾“å‡ºç‰ˆæœ¬ä¿¡æ¯
program.version(
  Printer.fromString(
    `     \n               å¿«é€Ÿç”Ÿæˆæ¥å£å£°æ˜æ–‡ä»¶ v${_version}\n${versionStr}`,
  ),
);

// åˆ›å»ºå£°æ˜æ–‡ä»¶
const genInterface = async (name, source) => {
  let s = source;
  try {
    if (typeof s !== 'string') {
      const parser = JSON.stringify(source);
      s = parser;
    }
  } catch (error) {}
  const { lines } = await quicktypeJSON('ts', name, s);
  const data = lines.join('\n');
  // è¯»å–é…ç½®æ–‡ä»¶å†…å®¹
  try {
    fs.statSync(CONFIG_PATH);
    const file = fs.readFileSync(CONFIG_PATH, 'utf8');
    let configJsonObj = {};
    try {
      configJsonObj = JSON.parse(file);
      if (!isJson(configJsonObj)) throw new Error();
      if (configJsonObj.debug) {
        console.log(`[ DEBUG ]\nå‚æ•°: s\nç±»å‹: ${typeof s}\nå€¼: ${s}`);
      }
      // è¾“å‡º interface
      const { outputPath: op } = configJsonObj;
      const filePath = `${op}/${name}.ts`;
      try {
        fs.statSync(op);
      } catch (error) {
        fs.mkdirSync(op);
      }
      const writerStream = fs.createWriteStream(filePath);
      writerStream.write(data);
      writerStream.end();
      console.log(`ğŸ“ æ¥å£å·²ç”Ÿæˆï¼š${filePath}`);
    } catch (error) {
      console.log('é…ç½®ä¸æ˜¯ä¸€ä¸ªjsonæ–‡ä»¶');
    }
  } catch (error) {
    console.log(`è¯·å…ˆé…ç½®${CONFIG_FILE_NAME}`);
  }
};

// ç”Ÿæˆ/ä¿®æ”¹é…ç½®
program
  .command('config')
  .description('ç”Ÿæˆ/ä¿®æ”¹é…ç½®æ–‡ä»¶')
  .action(async () => {
    const { options } = await inquirer.prompt(PROMPTS_CONFIG_OPTIONS);
    if (!options.length) throw new Error('è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªé…ç½®é¡¹');
    const p2 = valueFindObject(PROMPTS_CONFIG, options, 'name');
    const configs = await inquirer.prompt(p2);
    let configJsonObj = {};

    const { proxy } = configs;
    if (proxy) {
      configs.proxy = JSON.parse(proxy);
    }

    try {
      fs.statSync(CONFIG_PATH);
      const file = fs.readFileSync(CONFIG_PATH, 'utf8');
      try {
        configJsonObj = JSON.parse(file);
        if (!isJson(configJsonObj)) throw new Error();
        Object.assign(configJsonObj, configs);
      } catch (error) {
        console.log('é…ç½®ä¸æ˜¯ä¸€ä¸ªjsonæ–‡ä»¶');
      }
    } catch (error) {
      configJsonObj = configs;
    }
    const configJsonStr = JSON.stringify(configJsonObj, null, '\t');
    const writerStream = fs.createWriteStream(CONFIG_PATH);
    writerStream.write(configJsonStr);
    writerStream.end();
    console.log(`ğŸŒŸ é…ç½®å®Œæˆï¼Œè¯·åœ¨ ${CONFIG_PATH} ä¸­æŸ¥çœ‹é…ç½®`);
  });

// æŒ‡ä»¤é›†
program
  .option('-n, --name <name>', 'æŒ‡å®šæ¥å£å')
  .option('-url, --api_url [api_url]', 'æŒ‡å®šæ¥å£è¯·æ±‚åœ°å€')
  .option('-o, --api_options [api_options]', 'æŒ‡å®šæ¥å£é€‰é¡¹')
  .action(async (options) => {
    const { name, api_url, api_options } = options;
    if (!Object.keys(options).length) throw new Error('è¯·é€‰æ‹©æ­£ç¡®çš„æŒ‡ä»¤');
    if (!name) throw new Error('æ¥å£åä¸èƒ½ä¸ºç©º');
    if (!api_url) throw new Error('æ¥å£è¯·æ±‚åœ°å€æˆ–æ•°æ®ä¸èƒ½ä¸ºç©º');

    const res = await fetch(api_url, api_options);

    genInterface(name, res);
  });

// é€šè¿‡cURLç”Ÿæˆå£°æ˜æ–‡ä»¶
program
  .command('data')
  .description('é€šè¿‡dataç”Ÿæˆå£°æ˜æ–‡ä»¶')
  .action(async () => {
    const { name, data } = await inquirer.prompt(PROMPTS_DATA);
    if (!name) throw new Error('æ¥å£åä¸èƒ½ä¸ºç©º');
    if (!data) throw new Error('dataä¸èƒ½ä¸ºç©º');

    genInterface(name, data);
  });

// é€šè¿‡cURLç”Ÿæˆå£°æ˜æ–‡ä»¶
program
  .command('curl')
  .description('é€šè¿‡cURLç”Ÿæˆå£°æ˜æ–‡ä»¶')
  .action(async () => {
    const { name, cURL } = await inquirer.prompt(PROMPTS_CURL);
    if (!name) throw new Error('æ¥å£åä¸èƒ½ä¸ºç©º');
    if (!cURL) throw new Error('cURLä¸èƒ½ä¸ºç©º');

    cp.exec(cURL, (error, stdout) => {
      if (error !== null) {
        throw new Error(error);
      }
      genInterface(name, stdout);
    });
  });

program.parse(cp.argv);
